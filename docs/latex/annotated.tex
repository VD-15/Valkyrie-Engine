\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1Application}{vlk\+::\+Application}} \\*Starts and stops the update loop }{\pageref{classvlk_1_1Application}}{}
\item\contentsline{section}{\mbox{\hyperlink{structvlk_1_1Application_1_1ApplicationArgs}{vlk\+::\+Application\+::\+Application\+Args}} \\*Container for application-\/related metadata }{\pageref{structvlk_1_1Application_1_1ApplicationArgs}}{}
\item\contentsline{section}{\mbox{\hyperlink{structvlk_1_1ApplicationExitEvent}{vlk\+::\+Application\+Exit\+Event}} \\*Sent when the final update loop has taken place and the application is about to exit }{\pageref{structvlk_1_1ApplicationExitEvent}}{}
\item\contentsline{section}{\mbox{\hyperlink{structvlk_1_1ApplicationStartEvent}{vlk\+::\+Application\+Start\+Event}} \\*Sent when the application starts and the first update loop is about to begin }{\pageref{structvlk_1_1ApplicationStartEvent}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1ArrayAllocator}{vlk\+::\+Array\+Allocator$<$ T, Capacity $>$}} \\*Allocator backed by a fixed-\/size bounded array }{\pageref{classvlk_1_1ArrayAllocator}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1ChunkAllocator}{vlk\+::\+Chunk\+Allocator$<$ T, Capacity $>$}} \\*Allocator backed by multiple fixed-\/size chunks }{\pageref{classvlk_1_1ChunkAllocator}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1Component}{vlk\+::\+Component$<$ T, Component\+Allocator $>$}} \\*Base class for user-\/defined components to inherit from }{\pageref{classvlk_1_1Component}}{}
\item\contentsline{section}{\mbox{\hyperlink{structvlk_1_1EarlyUpdateEvent}{vlk\+::\+Early\+Update\+Event}} \\*First event sent in the update loop. Always before \mbox{\hyperlink{structvlk_1_1UpdateEvent}{Update\+Event}} }{\pageref{structvlk_1_1EarlyUpdateEvent}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1Entity}{vlk\+::\+Entity$<$ T, Entity\+Allocator $>$}} }{\pageref{classvlk_1_1Entity}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1EventBus}{vlk\+::\+Event\+Bus$<$ T $>$}} }{\pageref{classvlk_1_1EventBus}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1EventListener}{vlk\+::\+Event\+Listener$<$ T $>$}} \\*Helper class for event listeners to inherit from. Automatically registers iteself to the appropriate \mbox{\hyperlink{classvlk_1_1EventBus}{event bus }} when constructed and removes itself when destructed }{\pageref{classvlk_1_1EventListener}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1HasAllocateFunc}{vlk\+::\+Has\+Allocate\+Func$<$ Alloc $>$}} \\*Ensures that type {\ttfamily Alloc} has a function called {\ttfamily Allocate} that returns a {\ttfamily void$\ast$} }{\pageref{classvlk_1_1HasAllocateFunc}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1HasCountFunc}{vlk\+::\+Has\+Count\+Func$<$ Alloc $>$}} \\*Ensures that type {\ttfamily Alloc} has a function called {\ttfamily Count} that returns a {\ttfamily Size} }{\pageref{classvlk_1_1HasCountFunc}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1HasDeallocateFunc}{vlk\+::\+Has\+Deallocate\+Func$<$ Alloc $>$}} \\*Ensures that type {\ttfamily Alloc} has a function called {\ttfamily Deallocate} that takes a {\ttfamily void$\ast$} as an argument and returns {\ttfamily void} }{\pageref{classvlk_1_1HasDeallocateFunc}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1HasFilterCountFunc}{vlk\+::\+Has\+Filter\+Count\+Func$<$ Alloc, Param $>$}} \\*Ensures that type {\ttfamily Alloc} has a function called {\ttfamily Count} that takes a {\ttfamily std\+::function$<$bool(\+Param$\ast$)$>$} and returns a {\ttfamily Size} }{\pageref{classvlk_1_1HasFilterCountFunc}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1HasFilterForEachFunc}{vlk\+::\+Has\+Filter\+For\+Each\+Func$<$ Alloc, Param $>$}} \\*Ensures that type {\ttfamily Alloc} has a function called {\ttfamily For\+Each} that takes two functions as arguments\+: A modifier function that returns void and takes a {\ttfamily Param$\ast$} as an argument A filter function that returns a bool and takes a {\ttfamily const Param$\ast$} as an argument }{\pageref{classvlk_1_1HasFilterForEachFunc}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1HasForEachFunc}{vlk\+::\+Has\+For\+Each\+Func$<$ Alloc, Param $>$}} \\*Ensures that type {\ttfamily Alloc} has a function called {\ttfamily For\+Each} that takes a function as an argument. This function should return void and should take a {\ttfamily Param$\ast$} as an argument }{\pageref{classvlk_1_1HasForEachFunc}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1IComponent}{vlk\+::\+I\+Component}} }{\pageref{classvlk_1_1IComponent}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1IEntity}{vlk\+::\+I\+Entity}} }{\pageref{classvlk_1_1IEntity}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1IEventListener}{vlk\+::\+I\+Event\+Listener$<$ T $>$}} \\*Base class for all event listeners. Do not use this directly, prefer \mbox{\hyperlink{classvlk_1_1EventListener}{vlk\+::\+Event\+Listener}}, that will automatically subscribe itself to the appropriate \mbox{\hyperlink{classvlk_1_1EventBus}{vlk\+::\+Event\+Bus}} when constructed }{\pageref{classvlk_1_1IEventListener}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1ISignalListener}{vlk\+::\+I\+Signal\+Listener}} \\*Base interface for entity signal listeners }{\pageref{classvlk_1_1ISignalListener}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1IsLogLevelEnabled}{vlk\+::\+Is\+Log\+Level\+Enabled$<$ L $>$}} \\*Helper class that statically-\/evaluates whether log events with severity \mbox{\hyperlink{namespacevlk_a8f4a29860db3d6e178a9777d1346843c}{Log\+Level}} should be sent }{\pageref{classvlk_1_1IsLogLevelEnabled}}{}
\item\contentsline{section}{\mbox{\hyperlink{structvlk_1_1LateUpdateEvent}{vlk\+::\+Late\+Update\+Event}} \\*Last event sent in the update loop. Always after \mbox{\hyperlink{structvlk_1_1UpdateEvent}{Update\+Event}} }{\pageref{structvlk_1_1LateUpdateEvent}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1LinkedAllocator}{vlk\+::\+Linked\+Allocator$<$ T $>$}} \\*Allocator backed by an unbounded linked-\/list }{\pageref{classvlk_1_1LinkedAllocator}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1LogEvent}{vlk\+::\+Log\+Event}} }{\pageref{classvlk_1_1LogEvent}}{}
\item\contentsline{section}{\mbox{\hyperlink{structvlk_1_1PostUpdateEvent}{vlk\+::\+Post\+Update\+Event}} \\*Sent once every frame, just after the update loop ends. Please don\textquotesingle{}t use this for game logic }{\pageref{structvlk_1_1PostUpdateEvent}}{}
\item\contentsline{section}{\mbox{\hyperlink{structvlk_1_1PreUpdateEvent}{vlk\+::\+Pre\+Update\+Event}} \\*Sent once every frame, just before the update loop starts. Please don\textquotesingle{}t use this for game logic }{\pageref{structvlk_1_1PreUpdateEvent}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1Signal}{vlk\+::\+Signal}} \\*Represents a dynamic event sent to an entity, Unlike events, which are statically defined and sent globally via the \mbox{\hyperlink{classvlk_1_1EventBus}{Event\+Bus}}, signals are completely dynamic and are sent only to the \mbox{\hyperlink{classvlk_1_1Entity}{Entity}} that recieves them. The components that are attached to the entity then process the signal by inheriting from \mbox{\hyperlink{classvlk_1_1ISignalListener}{I\+Signal\+Listener}} }{\pageref{classvlk_1_1Signal}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1SingletonAllocator}{vlk\+::\+Singleton\+Allocator$<$ T $>$}} \\*Single-\/instance allocator }{\pageref{classvlk_1_1SingletonAllocator}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1Thread}{vlk\+::\+Thread}} }{\pageref{classvlk_1_1Thread}}{}
\item\contentsline{section}{\mbox{\hyperlink{classvlk_1_1ThreadPool}{vlk\+::\+Thread\+Pool}} }{\pageref{classvlk_1_1ThreadPool}}{}
\item\contentsline{section}{\mbox{\hyperlink{structvlk_1_1UpdateEvent}{vlk\+::\+Update\+Event}} \\*Second event sent in the update loop. Always after \mbox{\hyperlink{structvlk_1_1EarlyUpdateEvent}{Early\+Update\+Event}} Always before \mbox{\hyperlink{structvlk_1_1LateUpdateEvent}{Late\+Update\+Event}} }{\pageref{structvlk_1_1UpdateEvent}}{}
\end{DoxyCompactList}
